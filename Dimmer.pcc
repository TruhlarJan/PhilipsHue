// Philips HUE Steuerung
// Eingang des Programmbausteins wird mit dem Ausgang der Lichtsteuerung (RGB, Dimmer, Ein/Aus) verbunden
//
// (c) 2013 by Romy Glauser
// FÜR LIVING COLORS GEN 2 - MIT HUE!
// 
// (c) 2015 Erweiterung durch Andreas Lackner-Werner um LUMITECH (rgbw) & Gruppenfunktionen sowei generelles Cleanup des Codes
//
// (c) 2015 Erweiterung durch Sven Thierfelder um cx/cy Farbsteuerung für hue-bulbs sowie Glühlampensimulation
// 

#define BUFF_SIZE 40000
#define RD_BLOCK_SIZE 128

int DEBUG_LEVEL=0;
int DIMMER_MIN=15;  
int DIMMER_MAX=100;

// Übergangszeit von einem Dimmwert zum nächsten (10 = 1 Sekunde)
int TRANSITION_TIME=10;

int DIMMER_SIMMIN[12];DIMMER_SIMMIN[0] = 154; //154 = 6400k
DIMMER_SIMMIN[1] = 154;
DIMMER_SIMMIN[2] = 154;
DIMMER_SIMMIN[3] = 154;
DIMMER_SIMMIN[4] = 154;
DIMMER_SIMMIN[5] = 154;
DIMMER_SIMMIN[6] = 154;
DIMMER_SIMMIN[7] = 154;
DIMMER_SIMMIN[8] = 154;
DIMMER_SIMMIN[9] = 154;
DIMMER_SIMMIN[10] = 154;
DIMMER_SIMMIN[11] = 154;

int DIMMER_SIMMAX[12];
DIMMER_SIMMAX[0] = 500; //370 = 2700k
DIMMER_SIMMAX[1] = 500;
DIMMER_SIMMAX[2] = 600;
DIMMER_SIMMAX[3] = 500;
DIMMER_SIMMAX[4] = 500;
DIMMER_SIMMAX[5] = 500;
DIMMER_SIMMAX[6] = 500;
DIMMER_SIMMAX[7] = 500;
DIMMER_SIMMAX[8] = 500;
DIMMER_SIMMAX[9] = 500;
DIMMER_SIMMAX[10] = 500;
DIMMER_SIMMAX[11] = 500;


// Bitte folgende Website:
// http://www.developers.meethue.com/documentation/getting-started 
// beachten um einen gültigen User-Namen zu generieren!
char* IP_ADDRESS = "192.168.1.211";
char* PORT = "80";
char* USERNAME = "j9PQCECQlbPMiYwhYJnanmFlhJzRAx1M5jReVWJV";



int inputType[12]; 

// Hier die Funktion des Eingangs definieren:
// 0 = RGB-Eingang (Eingang LoxoneFormat, 9-stellige Zahl die RGB codiert mit 100100100 für weiß. Ansteuerung der Lampe via Hue/Sat/Bri
// 1 = Dimmereingang. Eingangswert muss im Bereich DIMMER_MIN / DIMMER_MAX sein. Ansteuerung der Lampe via Bri.
// 2 = ON/OF - Eingang (z.B. für Steckdosen-Adapter)
// 4 = RGB-Eingang (wie '0', aber ansteuerung der Lampe via X/Y/Bri)
// 5 = Dimmereingang (wie '1', Ansteuerung der Lampe via Bri/Ct, Glühlampensimulation)

// Wenn Lampengruppen bestehen, dann diese Typen verwenden:
// 3 = RGB-Eingang (wie '0', aber steuert Lampengruppe via Hue/Sat/Bri)
// 6 = RGB-Eingang (wie '0', aber steuert Lampengruppe via X/Y/Bri)
// 7 = Dimmereingang, wie 1, aber für Gruppe oder Szene
//     für diese Gruppe eine Szene angegeben, so wird die Szene bei Wert 1 oder 100 gesetzt

inputType[0] = 1;  
inputType[1] = 1;
inputType[2] = -1;  
inputType[3] = -1;
inputType[4] = -1;
inputType[5] = -1;
inputType[6] = -1;
inputType[7] = -1;
inputType[8] = -1;
inputType[9] = -1;
inputType[10] = -1;
inputType[11] = -1;

int lightOrGroupID[12];   

// Zuweisung der Lampen- oder GruppenIDs. 
// Definiert welcher Eingang des Bausteins welche Lampe bzw. Gruppe ansteuert:
lightOrGroupID[0] = 1;  
lightOrGroupID[1] = 2;
lightOrGroupID[2] = 3;
lightOrGroupID[3] = 4;
lightOrGroupID[4] = 5;
lightOrGroupID[5] = 6;
lightOrGroupID[6] = 7;
lightOrGroupID[7] = 8;
lightOrGroupID[8] = 9;
lightOrGroupID[9] = 10;
lightOrGroupID[10] = 11;
lightOrGroupID[11] = 12;

// Zuweisung von Scenen zu Gruppen

char* sceneIDforGroup[12];
sceneIDforGroup[0] = "";
sceneIDforGroup[1] = "";
sceneIDforGroup[2] = "";
sceneIDforGroup[3] = "";
sceneIDforGroup[4] = "";
sceneIDforGroup[5] = "";
sceneIDforGroup[6] = "";
sceneIDforGroup[7] = "";
sceneIDforGroup[8] = "";
sceneIDforGroup[9] = "";
sceneIDforGroup[10] = "";
sceneIDforGroup[11] = "";

// Ende der Konfiguration...


char streamname[100];
sprintf(streamname, "/dev/tcp/%s/%s/", IP_ADDRESS, PORT);

int nEvents;

int LIGHT = 1;
int GROUP = 2;

void setBrightness(int lightID, float bri, int type, int idx) {
    char command[200];
    char cmdscene[100];
    char selector[20];
    // Normieren von 35-100 -> 1-255
    if (bri > 0) {
        bri = (bri - DIMMER_MIN )/( DIMMER_MAX - DIMMER_MIN )*254+1;
    }

    if (type==LIGHT) {
        sprintf(selector,"lights/%d/state", lightID);
    } else if (type==GROUP) {
        sprintf(selector,"groups/%d/action", lightID);
    }

    if (bri == 0) {
        sprintf(command, "{\"on\": false}");
        if (DEBUG_LEVEL > 0) printf("Light %d OFF", lightID);
    } else {
        if (strlen(sceneIDforGroup[idx]) != 0) {
          if (bri == 1 || bri == 255) {
                sprintf(cmdscene, ", \"scene\": \"%s\"", sceneIDforGroup[idx]);
            }
        }
        sprintf(command, "{\"on\": true, \"bri\": %d, \"transitiontime\": %d%s}", (int) (bri), TRANSITION_TIME, cmdscene);
        if (DEBUG_LEVEL > 0) printf("Light %d ON %d%%", lightID, (int) ((bri-1)/2.55)+1);
    }
    
    sendCommand(selector, command);
}

void sendCommand(char* selector, char* command) {

if (DEBUG_LEVEL > 1) char szBuffer[BUFF_SIZE];
char szTmpBuffer[RD_BLOCK_SIZE];
int nCnt;
int nBytesReceived = 0;
int blData = 0;

    STREAM* TcpStream = stream_create(streamname,0,0);
    if (TcpStream == NULL) {
        printf("Creating Stream failed");
        stream_close(TcpStream);
        return;
    }

    char buffer[1024];
    sprintf(buffer, "PUT /api/%s/%s HTTP/1.1\r\nHost: %s\r\nConnection: keep-alive\r\nContent-Length: %d\r\n\r\n%s", 
            USERNAME, selector, IP_ADDRESS, strlen(command), command);
    if (DEBUG_LEVEL > 1) printf(buffer);
    stream_write(TcpStream,buffer,sizeof(buffer));
    stream_flush(TcpStream);
    // read stream
    do
    {
        nCnt = stream_read(TcpStream,szTmpBuffer,RD_BLOCK_SIZE,4000);
        if (nCnt + nBytesReceived > BUFF_SIZE)
        {
            nBytesReceived = -1;
            break; //File is too large
        }
        else if(nCnt > 0)
        {
            if (DEBUG_LEVEL > 1) strncpy((char*)szBuffer + nBytesReceived, szTmpBuffer, nCnt);
            nBytesReceived += nCnt;
        }
    }
    while (nCnt > 0);
    if (DEBUG_LEVEL > 1) printf(strstr(szBuffer,"[{"));
    //sleep(150);
    stream_close(TcpStream);
} 

// main
while (TRUE) {
    nEvents = getinputevent();
    int i;
    for (i = 0; i < 12; i++) {
        if (nEvents & 0x8 << i) {
            setBrightness(lightOrGroupID[i], getinput(i), LIGHT, 0);
        }
    }
    sleep(100);
}
