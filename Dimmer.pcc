// Philips HUE Steuerung
// Eingang des Programmbausteins wird mit dem Ausgang der Lichtsteuerung (RGB, Dimmer, Ein/Aus) verbunden
//
// (c) 2013 by Romy Glauser
// FÜR LIVING COLORS GEN 2 - MIT HUE!
// 
// (c) 2015 Erweiterung durch Andreas Lackner-Werner um LUMITECH (rgbw) & Gruppenfunktionen sowei generelles Cleanup des Codes
//
// (c) 2015 Erweiterung durch Sven Thierfelder um cx/cy Farbsteuerung für hue-bulbs sowie Glühlampensimulation
// 

#define BUFF_SIZE 40000
#define RD_BLOCK_SIZE 128

int DIMMER_MIN=15;  
int DIMMER_MAX=100;

// Übergangszeit von einem Dimmwert zum nächsten (10 = 1 Sekunde)
int TRANSITION_TIME=10;

int DIMMER_SIMMIN[12];DIMMER_SIMMIN[0] = 154; //154 = 6400k
DIMMER_SIMMIN[1] = 154;
DIMMER_SIMMIN[2] = 154;
DIMMER_SIMMIN[3] = 154;
DIMMER_SIMMIN[4] = 154;
DIMMER_SIMMIN[5] = 154;
DIMMER_SIMMIN[6] = 154;
DIMMER_SIMMIN[7] = 154;
DIMMER_SIMMIN[8] = 154;
DIMMER_SIMMIN[9] = 154;
DIMMER_SIMMIN[10] = 154;
DIMMER_SIMMIN[11] = 154;

int DIMMER_SIMMAX[12];
DIMMER_SIMMAX[0] = 500; //370 = 2700k
DIMMER_SIMMAX[1] = 500;
DIMMER_SIMMAX[2] = 600;
DIMMER_SIMMAX[3] = 500;
DIMMER_SIMMAX[4] = 500;
DIMMER_SIMMAX[5] = 500;
DIMMER_SIMMAX[6] = 500;
DIMMER_SIMMAX[7] = 500;
DIMMER_SIMMAX[8] = 500;
DIMMER_SIMMAX[9] = 500;
DIMMER_SIMMAX[10] = 500;
DIMMER_SIMMAX[11] = 500;


// Bitte folgende Website:
// http://www.developers.meethue.com/documentation/getting-started 
// beachten um einen gültigen User-Namen zu generieren!
char* IP_ADDRESS = "192.168.1.211";
char* PORT = "80";
char* USERNAME = "j9PQCECQlbPMiYwhYJnanmFlhJzRAx1M5jReVWJV";

int lightOrGroupID[12];   

// Zuweisung der Lampen- oder GruppenIDs. 
// Definiert welcher Eingang des Bausteins welche Lampe bzw. Gruppe ansteuert:
lightOrGroupID[0] = 1;  
lightOrGroupID[1] = 2;
lightOrGroupID[2] = 3;
lightOrGroupID[3] = 4;
lightOrGroupID[4] = 5;
lightOrGroupID[5] = 6;
lightOrGroupID[6] = 7;
lightOrGroupID[7] = 8;
lightOrGroupID[8] = 9;
lightOrGroupID[9] = 10;
lightOrGroupID[10] = 11;
lightOrGroupID[11] = 12;


char streamname[100];
sprintf(streamname, "/dev/tcp/%s/%s/", IP_ADDRESS, PORT);

int nEvents;

void setBrightness(int lightID, float bri) {
    char command[200];
    char cmdscene[100];
    char selector[20];
    // Normieren von 35-100 -> 1-255
    if (bri > 0) {
        bri = (bri - DIMMER_MIN )/( DIMMER_MAX - DIMMER_MIN )*254+1;
    }

    sprintf(selector,"lights/%d/state", lightID);

    if (bri == 0) {
        sprintf(command, "{\"on\": false}");
    } else {
        sprintf(command, "{\"on\": true, \"bri\": %d, \"transitiontime\": %d%s}", (int) (bri), TRANSITION_TIME, cmdscene);
    }
    
    sendCommand(selector, command);
}

void sendCommand(char* selector, char* command) {

    char szTmpBuffer[RD_BLOCK_SIZE];
    int nCnt;
    int nBytesReceived = 0;
    int blData = 0;

    STREAM* TcpStream = stream_create(streamname,0,0);
    if (TcpStream == NULL) {
        printf("Creating Stream failed");
        stream_close(TcpStream);
        return;
    }

    char buffer[1024];
    sprintf(buffer, "PUT /api/%s/%s HTTP/1.1\r\nHost: %s\r\nConnection: keep-alive\r\nContent-Length: %d\r\n\r\n%s", 
            USERNAME, selector, IP_ADDRESS, strlen(command), command);
    stream_write(TcpStream,buffer,sizeof(buffer));
    stream_flush(TcpStream);
    // read stream
    do
    {
        nCnt = stream_read(TcpStream,szTmpBuffer,RD_BLOCK_SIZE,4000);
        if (nCnt + nBytesReceived > BUFF_SIZE)
        {
            nBytesReceived = -1;
            break; //File is too large
        }
        else if(nCnt > 0)
        {
            nBytesReceived += nCnt;
        }
    }
    while (nCnt > 0);
    stream_close(TcpStream);
} 

// main
while (TRUE) {
    nEvents = getinputevent();
    int i;
    for (i = 0; i < 12; i++) {
        if (nEvents & 0x8 << i) {
            setBrightness(lightOrGroupID[i], getinput(i));
        }
    }
    sleep(100);
}
